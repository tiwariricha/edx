{"version":3,"sources":["webpack:///./lms/static/completion/js/CompletionOnViewService.js?54b6","webpack:///./lms/static/completion/js/ViewedEvent.js?aa58"],"names":["completedBlocksKeys","Set","markBlocksCompletedOnViewIfNeeded","runtime","containerElement","blockElements","$","find","get","length","tracker","forEach","blockElement","markCompletedOnViewAfterDelay","parseInt","dataset","addElement","addHandler","event","blockKey","usageId","has","elementHasBeenViewed","ajax","type","url","handlerUrl","data","JSON","stringify","completion","then","add","throttle","fn","wait","time","delay","now","Date","ElementViewing","el","viewedAfterMs","callback","topSeen","bottomSeen","seenForMs","becameVisibleAt","undefined","hasBeenViewed","getBoundingClientRect","setTimeout","checkIfViewed","getTotalTimeSeen","areViewedCriteriaMet","ViewedEventTracker","elementViewings","handlers","registerDomHandlers","element","callHandlers","updateVisible","handler","push","elv","rect","getBoundingRect","visible","top","window","innerHeight","markTopSeen","bottom","markBottomSeen","handleVisible","handleNotVisible","onscroll","onresize"],"mappings":"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","file":"CompletionOnViewService.js","sourcesContent":["import { ViewedEventTracker } from './ViewedEvent';\n\nconst completedBlocksKeys = new Set();\n\nexport function markBlocksCompletedOnViewIfNeeded(runtime, containerElement) {\n  const blockElements = $(containerElement).find(\n    '.xblock-student_view[data-mark-completed-on-view-after-delay]',\n  ).get();\n\n  if (blockElements.length > 0) {\n    const tracker = new ViewedEventTracker();\n\n    blockElements.forEach((blockElement) => {\n      const markCompletedOnViewAfterDelay = parseInt(\n        blockElement.dataset.markCompletedOnViewAfterDelay, 10,\n      );\n      if (markCompletedOnViewAfterDelay >= 0) {\n        tracker.addElement(blockElement, markCompletedOnViewAfterDelay);\n      }\n    });\n\n    tracker.addHandler((blockElement, event) => {\n      const blockKey = blockElement.dataset.usageId;\n      if (blockKey && !completedBlocksKeys.has(blockKey)) {\n        if (event.elementHasBeenViewed) {\n          $.ajax({\n            type: 'POST',\n            url: runtime.handlerUrl(blockElement, 'publish_completion'),\n            data: JSON.stringify({\n              completion: 1.0,\n            }),\n          }).then(\n            () => {\n              completedBlocksKeys.add(blockKey);\n              blockElement.dataset.markCompletedOnViewAfterDelay = 0;\n            },\n          );\n        }\n      }\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lms/static/completion/js/CompletionOnViewService.js","/** Ensure that a function is only run once every `wait` milliseconds */\nfunction throttle(fn, wait) {\n  let time = 0;\n  function delay() {\n    // Do not call the function until at least `wait` seconds after the\n    // last time the function was called.\n    const now = Date.now();\n    if (time + wait < now) {\n      time = now;\n      fn();\n    }\n  }\n  return delay;\n}\n\n\nexport class ElementViewing {\n  /**\n   * A wrapper for an HTMLElement that tracks whether the element has been\n   * viewed or not.\n   */\n  constructor(el, viewedAfterMs, callback) {\n    this.el = el;\n    this.viewedAfterMs = viewedAfterMs;\n    this.callback = callback;\n\n    this.topSeen = false;\n    this.bottomSeen = false;\n    this.seenForMs = 0;\n    this.becameVisibleAt = undefined;\n    this.hasBeenViewed = false;\n  }\n\n  getBoundingRect() {\n    return this.el.getBoundingClientRect();\n  }\n\n  /** This element has become visible on screen.\n   *\n   * (may be called even when already on screen though)\n   */\n  handleVisible() {\n    if (!this.becameVisibleAt) {\n      this.becameVisibleAt = Date.now();\n      // We're now visible; after viewedAfterMs, if the top and bottom have been\n      // seen, this block will count as viewed.\n      setTimeout(\n        () => {\n          this.checkIfViewed();\n        },\n        this.viewedAfterMs - this.seenForMs,\n      );\n    }\n  }\n\n  handleNotVisible() {\n    if (this.becameVisibleAt) {\n      this.seenForMs = Date.now() - this.becameVisibleAt;\n    }\n    this.becameVisibleAt = undefined;\n  }\n\n  markTopSeen() {\n    // If this element has been seen for enough time, but the top wasn't visible, it may now be\n    // considered viewed.\n    this.topSeen = true;\n    this.checkIfViewed();\n  }\n\n  markBottomSeen() {\n    this.bottomSeen = true;\n    this.checkIfViewed();\n  }\n\n  getTotalTimeSeen() {\n    if (this.becameVisibleAt) {\n      return this.seenForMs + (Date.now() - this.becameVisibleAt);\n    }\n    return this.seenForMs;\n  }\n\n  areViewedCriteriaMet() {\n    return this.topSeen && this.bottomSeen && (this.getTotalTimeSeen() >= this.viewedAfterMs);\n  }\n\n  checkIfViewed() {\n    // User can provide a \"now\" value for testing purposes.\n    if (this.hasBeenViewed) {\n      return;\n    }\n    if (this.areViewedCriteriaMet()) {\n      this.hasBeenViewed = true;\n      // Report to the tracker that we have been viewed\n      this.callback(this.el, { elementHasBeenViewed: this.hasBeenViewed });\n    }\n  }\n}\n\n\nexport class ViewedEventTracker {\n  /**\n   * When the top or bottom of an element is first viewed, and the entire\n   * element is viewed for a specified amount of time, the callback is called,\n   * passing the element that was viewed, and an event object having the\n   * following field:\n   *\n   * *   hasBeenViewed (bool): true if all the conditions for being\n   *     considered \"viewed\" have been met.\n   */\n  constructor() {\n    this.elementViewings = new Set();\n    this.handlers = [];\n    this.registerDomHandlers();\n  }\n\n  /** Add an element to track.  */\n  addElement(element, viewedAfterMs) {\n    this.elementViewings.add(\n     new ElementViewing(\n       element,\n       viewedAfterMs,\n       (el, event) => this.callHandlers(el, event),\n      ),\n    );\n    this.updateVisible();\n  }\n\n  /** Register a new handler to be called when an element has been viewed.  */\n  addHandler(handler) {\n    this.handlers.push(handler);\n  }\n\n  /** Mark which elements are currently visible.\n   *\n   *  Also marks when an elements top or bottom has been seen.\n   * */\n  updateVisible() {\n    this.elementViewings.forEach((elv) => {\n      if (elv.hasBeenViewed) {\n        return;\n      }\n\n      const now = Date.now(); // Use the same \"now\" for all calculations\n      const rect = elv.getBoundingRect();\n      let visible = false;\n\n      if (rect.top > 0 && rect.top < window.innerHeight) {\n        elv.markTopSeen(now);\n        visible = true;\n      }\n      if (rect.bottom > 0 && rect.bottom < window.innerHeight) {\n        elv.markBottomSeen(now);\n        visible = true;\n      }\n      if (rect.top < 0 && rect.bottom > window.innerHeight) {\n        visible = true;\n      }\n\n      if (visible) {\n        elv.handleVisible(now);\n      } else {\n        elv.handleNotVisible(now);\n      }\n    });\n  }\n\n  registerDomHandlers() {\n    window.onscroll = throttle(() => this.updateVisible(), 100);\n    window.onresize = throttle(() => this.updateVisible(), 100);\n    this.updateVisible();\n  }\n\n  /** Call the handlers for all newly-viewed elements and pause tracking\n   *  for recently disappeared elements.\n   */\n  callHandlers(el, event) {\n    this.handlers.forEach((handler) => {\n      handler(el, event);\n    });\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./lms/static/completion/js/ViewedEvent.js"],"sourceRoot":""}